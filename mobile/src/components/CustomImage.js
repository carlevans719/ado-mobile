// @ts-check

import React, { useEffect, useState } from 'react';
import { ImageBackground } from 'react-native';
import { parse } from 'svg-parser';
import { SvgXml } from 'react-native-svg';

import Loading from './Loading';

/**
 * Convert the AST generated by svg-parser/parse back to an XML string
 */ 
const svgAstToString = (ast) => {
  if (ast.value) {
    return ast.value;
  }

  const openTagParts = [];
  openTagParts.push('<');
  openTagParts.push(ast.tagName);
  for (let key in ast.properties) {
    openTagParts.push(' ')
    openTagParts.push(key)
    openTagParts.push('="')
    openTagParts.push(String(ast.properties[key]).replace(/"/g, "'"));
    openTagParts.push('"')
  }
  openTagParts.push('>');

  const openTag = openTagParts.join('');
  const closeTag = `</${ast.tagName}>`;

  return [
    openTag,
    ast.children ? ast.children.map(svgAstToString).join('') : '',
    closeTag,
  ].join('');
};

/**
 * Modify an AST generated by svg-parser/parse in two ways:
 * 1. move all nested <Svg> elements after all their respective siblings
 * 2. wrap any <ClipPath>s inside a <Defs> if not already in one
 */
const modifySvg = (elem) => {
  const newElem = JSON.parse(JSON.stringify(elem));
  if (newElem.children) {
    newElem.children = [];
  }

  const moveToEnd = [];

  for (let i = 0; i < (elem.children || []).length; i++) {
    const child = elem.children[i];
    if (child.tagName === 'svg') {
      moveToEnd.push(modifySvg(child));
    } else if (elem.tagName !== 'defs' && child.tagName === 'clipPath') {
      newElem.children.push({
        type: 'element',
        tagName: 'defs',
        properties: {},
        children: [modifySvg(child)],
      });
    } else {
      newElem.children.push(modifySvg(child));
    }
  }

  moveToEnd.forEach(child => newElem.children.push(child));

  return newElem;
};

const CustomImage = ({ source, children, ...props }) => {
  const [svgXml, setSvgXml] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;

    if (source && source.uri) {
      fetch(source.uri)
        .then(res => {
          if (res.headers.get('content-type')?.includes('svg')) {
            return res.text();
          }

          return Promise.reject()
        })
        .then(svgText => {
          if (!cancelled) {
            setSvgXml(svgAstToString(modifySvg(parse(svgText)).children[0]));
            setIsLoading(false);
          }
        })
        .catch(err => {
          if (!cancelled) {
            setIsLoading(false);
            console.error(err.message);
          }
        });
    }

    return () => {
      cancelled = true;
    };
  }, []);

  if (isLoading) {
    return <Loading />;
  }

  if (svgXml) {
    return <SvgXml xml={svgXml} />;
  }

  return <ImageBackground {...props} source={source}>{children}</ImageBackground>;
};

export default CustomImage;
